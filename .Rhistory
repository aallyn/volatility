ungroup() %>%
filter(yr_cnt > 5, ##at least half the data duration
avg_value > 5000, ##at least 5k a year on avg
!HULLNUM == "", !HULLNUM %in% unkown_boat$HULLNUM, ###eliminating the unkown boat categories
!HULLNUM == "FROM_SHORE", ###eliminating the 'FROM_SHORE CATEGORIES
!HULLNUM == "000000") %>%
na.omit() ###eliminates NA rows, i.e. the first year for growth rate
#boat input dataset
boat_analysis_summary <- boat_processing %>%
group_by(HULLNUM) %>%
mutate(
avg_value = mean(total_value),
avg_log_value = mean(log(total_value)),
cv_revenue = sd(total_value) / mean(total_value),
log_cv_revenue_boat = log(cv_revenue),
cv_log_revenue_boat = sd(log_total_value) / mean(log_total_value),
avg_growth = mean(growth),
sd_growth = sd(growth),  ##calculated but will not use
avg_index = mean(index),
avg_pport = mean(proportion) * 100, #% vaught at primary port, a measure of transience
value_cat = case_when(
avg_value > 1000000 ~ "> $1,000,000",
avg_value > 500000 ~ "$500,000-$1,000,000",
avg_value > 100000 ~ "$100,000-$500,000",
avg_value > 50000 ~ "$50,000-$100,000",
avg_value > 5000 ~ "$5,000-$50,000"),
value_cat = factor(value_cat,
levels = c("$5,000-$50,000","$50,000-$100,000","$100,000-$500,000",
"$500,000-$1,000,000", "> $1,000,000"))) %>%   ###port level information
distinct(HULLNUM, port_tidy, mega_subregion, yr_cnt, avg_value, avg_log_value,
cv_revenue, log_cv_revenue_boat, cv_log_revenue_boat, avg_growth, sd_growth, avg_index, avg_pport, value_cat)
#primary port list
primary_port_list <- primary_port %>% ungroup() %>%
select(port_tidy) %>%
distinct(port_tidy)
##INDEX CALC -- PORT ####
#port * year
port_year <- cfders_raw %>%
group_by(year, port_tidy) %>%
mutate(total_value = sum(value)) %>%
distinct(year, port_tidy, total_value) %>%
arrange(port_tidy, year, total_value)
#spp * port * year
spp_port_year <- cfders_raw %>%
group_by(year, spp, port_tidy) %>%
mutate(value = sum(value)) %>%
distinct(year, spp, port_tidy, value) %>%
arrange(port_tidy, year, value)
#index calculation
port_index_calc <- left_join(port_year, spp_port_year,
by = c("year" = "year", "port_tidy" = "port_tidy")) %>%
mutate(temp_index = (value / total_value)^2) %>%
group_by(year, port_tidy) %>%
mutate(index = 1/ sum(temp_index)) %>%
distinct(year, port_tidy, total_value, index) %>%
arrange(port_tidy, year) %>% na.omit()
##vARIABLE CREATION -- PORT ####
#right now we have a rolling mean, perhaps we could duplicate our observations every 4 years,
#calculate cv and all 'averages' over that period to inflate sample size for ports
port_processing <- port_index_calc %>%
group_by(port_tidy) %>%
mutate(
log_total_value = log(total_value),
growth = ((total_value - lag(total_value)) / lag(total_value))*100,
rev_var = roll_sd(total_value, 3, na.rm = TRUE, align = "right", fill = NA),
rev_mean = roll_mean(total_value, 3, na.rm = TRUE, align = "right", fill = NA),
rev_cv = rev_var / rev_mean ) %>%
filter(port_tidy %in% primary_port_list$port_tidy)
port_analysis_summary <- port_processing %>%
group_by(port_tidy) %>%
summarise(
yr_cnt = n_distinct(year),
avg_index = mean(index),
avg_value = mean(total_value),
log_avg_value = log(avg_value),
avg_growth = mean(growth),
cv_revenue = sd(total_value) / mean(total_value),
log_cv_revenue = log(cv_revenue),
cv_log_revenue = sd(log_total_value) / mean(log_total_value),
sd_growth = sd(growth)) %>%
rename(port_index = avg_index, port_yr = yr_cnt, port_value = avg_value,
port_log_value = log_avg_value, port_growth = avg_growth,
port_cv_revenue = cv_revenue, port_sd_growth = sd_growth)
#ANALYSIS DATASET ####
#interpretation reference: http://home.wlu.edu/~gusej/econ398/notes/logRegressions.pdf
boat_port_input_temp <- left_join(boat_analysis_summary, port_analysis_summary,
by = c("port_tidy" = "port_tidy"))
#assessment of normality for cv revenues
a <- ggplot(boat_port_input_temp, aes(avg_index, cv_revenue)) + geom_boxplot()
b <- ggplot(boat_port_input_temp, aes(avg_index, port_cv_revenue)) + geom_boxplot()
grid.arrange(a, b, nrow=1)
#assessment of normality for logged cv revenues and cv of logged revenues
a_logcv <- ggplot(boat_port_input_temp, aes(log_cv_revenue_boat)) + geom_density()
b_logcv <- ggplot(boat_port_input_temp, aes(log_cv_revenue)) + geom_density()
grid.arrange(a_logcv, b_logcv, nrow=1)
a_cv_log <- ggplot(boat_port_input_temp, aes(cv_log_revenue_boat)) + geom_density()
b_cv_log <- ggplot(boat_port_input_temp, aes(cv_log_revenue)) + geom_density()
grid.arrange(a_cv_log, a_logcv, b_cv_log, b_logcv, nrow=2)
#now filter the above via boxplot method
#filtering based on visual inspection: goal is to get both cv's to be slightly normal
boat_port_input <- boat_port_input_temp %>% filter(cv_revenue < 1.25, port_cv_revenue < .7,
!port_tidy %in% c('OCEANSIDE_NY','BIRCHHARBOR_ME')) ##super volatile
#validting via final input dataset via plot
a <- ggplot(boat_port_input, aes(avg_index, cv_revenue)) + geom_boxplot() + ggtitle("boat")
b <- ggplot(boat_port_input, aes(avg_index, port_cv_revenue)) + geom_boxplot() + ggtitle("port")
c <- ggplot(boat_port_input, aes(cv_revenue)) + geom_density() + ggtitle("boat")
d <- ggplot(boat_port_input, aes( port_cv_revenue)) + geom_density() + ggtitle("port")
#printing plot
grid.arrange(a, b, c, d, nrow=2)
grid.arrange(a_cv_log, a_logcv, b_cv_log, b_logcv, nrow=2)
?termplot
?plot.lm
# clean regression script: boats, ports, then all variables
# vessel results seem def 'hill shaped.' Port results are not significant
# using same form as boats. As an alterantive, port diversity index is used
# to predict vessel level CV
# stepwise regression IDs full regresion form as best fit
x <- c("sqldf", "tidyverse", "RcppRoll", "ggthemes", "moments", "gridExtra", "broom", "viridis",
"sjPlot", "jtools","ggstance")
lapply(x, require, character.only = TRUE) ##applying the function require to each point in the vector x
require(sjPlot) #loading sjPlot, did not load above for some reason
#reading in analysis data
input <- read.csv("C:/Users/brian/Dropbox/COCA/Volatility Diversity_Project/redo/boat_port_input.csv")
# boat-level regressions: ####
#scope is lme --> geo --> operation size####
#lme-scale
lme_boat <- lm(cv_revenue ~ avg_index + I(avg_index^2) + avg_log_value,
input)
#geo-level regressions
geo_boat <- input %>% group_by(mega_subregion) %>%
do(model = lm(cv_revenue ~ avg_index + I(avg_index^2) + avg_log_value,.))
#readable reg outputs
tidy_geo_boat <- geo_boat %>% tidy(model)
#operation-level regreesions
value_boat <- input %>% group_by(value_cat) %>%
do(model = lm(cv_revenue ~ avg_index + I(avg_index^2) + avg_log_value,.))
#readable reg outputs
tidy_value_boat <- value_boat %>% tidy(model)
# port - level regressions: ####
#scope is lme --> geo
#reducing dataset to include only ports
input_port <- input %>% distinct(port_tidy, port_cv_revenue, port_index, port_value, mega_subregion)
#lme-scale -- not sig!
lme_port <- lm(port_cv_revenue ~ port_index + I(port_index^2) + port_value,
input_port)
#geo-scale -- not sig!
geo_port <- input_port %>% group_by(mega_subregion) %>%
do(model = lm(port_cv_revenue ~ port_index + I(port_index^2) + port_value,.))
#readable reg outputs
tidy_geo_port <- geo_port %>% tidy(model)
#alternative: using port diversity to predict vessel diversity
lme_port_alt_quad <- lm(port_cv_revenue ~ port_index + I(port_index^2) + port_value,
input)
lme_port_alt <- lm(port_cv_revenue ~ port_index + I(port_index^2) + port_value,
input)
#printing results...quadratic form does not look important
sjt.lm(lme_port_alt_quad,  emph.p = TRUE, digits.est = 3)
sjt.lm(lme_port_alt,  emph.p = TRUE, digits.est = 3)
# master regresion: motivation is to get at the effect of each variable without sub-sampling.
#in addition we want to bring in port diversity as well, are diverse ports
#made up of diverse or specialized operators?
#we want to pick the best form for this multiple regression, this is asasisted by
#the MASS / leaps package
#stepwise regresssion package
library(leaps)
#all-subsets regression package
library(MASS)
#Tutorial using both: https://www.statmethods.net/stats/regression.html
#proto-master script
full_reg <- lm(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
avg_log_value + log(port_value) + mega_subregion, input)
#full regression results table
sjt.lm(full_reg,  emph.p = TRUE, digits.est = 3)
#full regression results plotted
plot_model(full_reg)
#using leaps to 'select' best model
#picking best model via an all-subsets regression using the leaps() package
#note the 'nbest' selects the top x models, here it is 10
leaps <- regsubsets(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
avg_log_value + log(port_value) + mega_subregion, data = input, nbest = 5)
#results from all-subsets regression (LOOK AT PLOT)
summary(leaps)
##plot a table of models, models are ordered based on stat of interest (i.e. r2, aic, bic)
plot(leaps, scale = "r2")
#looks like full model has biggest affect?
effect_plot(full_reg, pred = cv_revenue, interval = TRUE)
effect_plot(full_reg, pred = mega_subregion, interval = TRUE)
effect_plot(full_reg, pred = mega_subregion, interval = TRUE)
effect_plot(full_reg, pred = avg_index, interval = TRUE)
effect_plot(full_reg, pred = port_index, interval = TRUE)
boat <- effect_plot(full_reg, pred = port_index, interval = TRUE)
port <- effect_plot(full_reg, pred = avg_index, interval = TRUE)
grid.arrange(boat,port, rows=1)
grid.arrange(boat,port, nrow=1)
grid.arrange(boat,port, nrow=2)
boat <- effect_plot(full_reg, pred = port_index, interval = TRUE, plot.points = TRUE)
boat <- effect_plot(full_reg, pred = port_index, interval = TRUE, plot.points = TRUE)
port <- effect_plot(full_reg, pred = avg_index, interval = TRUE)
grid.arrange(boat,port, nrow=2)
boat <- effect_plot(full_reg, pred = port_index, interval = TRUE)
port <- effect_plot(full_reg, pred = avg_index, interval = TRUE)
grid.arrange(boat,port, nrow=2)
boat <- effect_plot(full_reg, pred = port_index, interval = TRUE)
port <- effect_plot(full_reg, pred = avg_index, interval = TRUE)
value <- effect_plot(full_reg, pred = avg_log_value, interval = TRUE)
grid.arrange(boat,port, value, nrow=3)
#looks like full model has biggest affect?
#coefficient direction
plot_summs(full_reg, scale = TRUE, plot.distributions = TRUE)
library(effects)
alleffects_fullreg <- allEffects(full_reg)
plot(alleffects_fullreg)
?ggeffects
install.packages("ggeffects")
install.packages("ggeffects")
library(ggeffects)
data("efc")
View(efc)
View(efc)
#regression from dataset, on first glance only c12hour is a continuous variable
fit <- lm(barthtot ~ c12hour + neg_c_7 + c161sex + c172code, data = efc)
summary(fit)
ggpredict(fit, terms = "c12hour")
mydf <- ggpredict(fit, terms = "c12hour")
ggplot(mydf, aes(x, predicted)) + geom_line()
x <- c("sqldf", "tidyverse", "RcppRoll", "ggthemes", "moments", "gridExtra", "broom", "viridis",
"sjPlot", "jtools","ggstance")
lapply(x, require, character.only = TRUE)
mydf <- ggpredict(fit, terms = "c12hour")
ggplot(mydf, aes(x, predicted)) + geom_line()
ggpredict(fit, terms = c("c12hour", "c172code"))
mydf <- ggpredict(fit, terms = c("c12hour", "c172code"))
ggplot(mydf, aes(x, predicted, colour = group)) + geom_line()
ggpredict(full_reg, terms = c("avg_index"))
ggplot(mydf, aes(x, predicted)) + geom_line()
##trying the same but for our data
ggpredict(full_reg, terms = c("I(avg_index^2)"))
ggplot(mydf, aes(x, predicted)) + geom_line()
##trying the same but for our data, ahh not working at this point
ggpredict(full_reg, terms = c("I(avg_index^2)"))
mydata <- ggpredict(full_reg, terms = c("I(avg_index^2)"))
ggplot(mydata, aes(x, predicted)) + geom_line()
##trying the same but for our data, ahh not working at this point
mydata <- ggpredict(full_reg, terms = c("avg_index"))
ggplot(mydata, aes(x, predicted)) + geom_line()
mydata <- ggpredict(full_reg, terms = c("avg_index"))
ggplot(mydata, aes(x, predicted)) + geom_line()
mydata <- ggpredict(full_reg, terms = c("avg_index", "megasubregion"))
ggplot(mydata, aes(x, predicted, colour = group)) + geom_line()
##trying the same but for our data, ahh not working at this point
mydata <- ggpredict(full_reg, terms = c("avg_index", "megasubregion"))
##trying the same but for our data, ahh not working at this point
mydata <- ggpredict(full_reg, terms = c("avg_index", "mega_subregion"))
ggplot(mydata, aes(x, predicted, colour = group)) + geom_line()
##trying the same but for our working but weird!!!!
mydata <- ggpredict(full_reg, terms = c("avg_index", "mega_subregion"))
ggplot(mydata, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
summary(full_reg)
View(mydata)
View(input)
View(mydf)
View(efc)
?ggpredict
mydata <- ggpredict(full_reg,
terms = c("avg_index [1.00:8.00]", "mega_subregion"))
ggplot(mydata, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
View(mydata)
##trying the same but for our working but weird!!!!, faceting def way to go,
##i can do my other stuff here now to, like the sample poylgons and rippons
index_value <- seq(from = 1, to = 8, by = 0.1)
index_value
mydata <- ggpredict(full_reg,
terms = c("avg_index [index_value]", "mega_subregion"))
ggplot(mydata, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
View(mydata)
##trying the same but for our working but weird!!!!, faceting def way to go,
##i can do my other stuff here now to, like the sample poylgons and rippons
index_value <- seq(from = 1, to = 8, by = 0.1)
index_value
mydata <- ggpredict(full_reg,
terms = c("avg_index [seq(from = 1, to = 8, by = 0.1)]", "mega_subregion"))
mydata
##trying the same but for our working but weird!!!!, faceting def way to go,
##i can do my other stuff here now to, like the sample poylgons and rippons
seq(from = 1, to = 8, by = 0.1)
mydata <- ggpredict(full_reg,
terms = c("avg_index [seq(from = 1, to = 8, by = 0.1)]", "mega_subregion"))
seq(from = 1, to = 8, by = 0.1)
mydata <- ggpredict(full_reg,
terms = c("avg_index [1:8 by 0.1)]", "mega_subregion"))
mydata <- ggpredict(full_reg,
terms = c("avg_index [1:8 by 0.1]", "mega_subregion"))
mydata <- ggpredict(full_reg,
terms = c("avg_index [1:8]", "mega_subregion"))
mydata <- ggpredict(full_reg,
terms = c("avg_index [*10]", "mega_subregion"))
mydata <- ggpredict(full_reg,
terms = c("avg_index", "mega_subregion"))
##trying the same but for our working but weird!!!!, faceting def way to go,
##i can do my other stuff here now to, like the sample poylgons and rippons
seq(from = 1, to = 8, by = 0.5)
mydata <- ggpredict(full_reg,
terms = c("avg_index
[1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0]
", "mega_subregion"))
ggplot(mydata, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
mydata <- ggpredict(full_reg,
terms = c("avg_index
[1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0, 3.25, 3.5, 3.75, 4.0,
4.25, 4.5, 4.75, 5.0, 5.25, 5.5, 5.75, 6.0, 6.25, 6.5, 6.75, 7.0,
7.25, 7.5, 7.75, 8.0]", "mega_subregion"))
ggplot(mydata, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
paste(x, collapse = ,)
paste(x, collapse = ",")
x <- seq(from = 1, to = 8, by = 0.5)
paste(x, collapse = ",")
x_mod <- paste(x, collapse = ",")
x_mod
mydata <- ggpredict(full_reg,
terms = c("avg_index
[x_mod]", "mega_subregion"))
View(mydata)
x <- seq(from = 1, to = 8, by = 0.1)
x_mod <- paste(x, collapse = ",")
mydata <- ggpredict(full_reg,
terms = c("avg_index [x_mod]", "mega_subregion"))
View(mydata)
x_mod <- paste(x, collapse = [,])
x_mod <- paste(x, collapse = "[,]")
x_mod <- paste(x, collapse = ",")
x <- seq(from = 1, to = 8, by = 0.2)
x_mod <- paste(x, collapse = ",")
x_mod
x <- seq(from = 1, to = 8, by = 0.1)
x_mod <- paste(x, collapse = ",")
x_mod
mydata <- ggpredict(full_reg,
terms = c("avg_index
[1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2,2.1,2.2,2.3,2.4,2.5,
2.6,2.7,2.8,2.9,3,3.1,3.2,3.3,3.4,3.5,3.6,3.7,3.8,3.9,4,
4.1,4.2,4.3,4.4,4.5,4.6,4.7,4.8,4.9,5,5.1,5.2,5.3,5.4,5.5,
5.6,5.7,5.8,5.9,6,6.1,6.2,6.3,6.4,6.5,6.6,6.7,6.8,6.9,7,
7.1,7.2,7.3,7.4,7.5,7.6,7.7,7.8,7.9,8]", "mega_subregion"))
mydata <- ggpredict(full_reg,
terms = c("avg_index
[1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2,2.1,2.2,2.3,2.4,2.5,
2.6,2.7,2.8,2.9,3,3.1,3.2,3.3,3.4,3.5,3.6,3.7,3.8,3.9,4,
4.1,4.2,4.3,4.4,4.5,4.6,4.7,4.8,4.9,5,5.1,5.2,5.3,5.4,5.5,
5.6,5.7,5.8,5.9,6,6.1,6.2,6.3,6.4,6.5,6.6,6.7,6.8,6.9,7,
7.1,7.2,7.3,7.4,7.5,7.6,7.7,7.8,7.9,8]", "mega_subregion"))
ggplot(mydata, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
x <- seq(from = 1, to = 8, by = 0.1)
x_mod <- paste(x, collapse = ", ")
x_mod
mydata <- ggpredict(full_reg,
terms = c("avg_index
[1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4, 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5, 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 6, 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8, 6.9, 7, 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, 7.9, 8]", "mega_subregion"))
ggplot(mydata, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
mydata <- ggpredict(full_reg,
terms = c("avg_index
[1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2,
2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3,
3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4,
4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5,
5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 6,
6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8, 6.9, 7,
7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, 7.9, 8]", "mega_subregion"))
ggplot(mydata, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
View(input)
leaps <- regsubsets(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
avg_log_value + log(port_value) + mega_subregion + value_cat, data = input, nbest = 5)
#results from all-subsets regression (LOOK AT PLOT)
summary(leaps)
##plot a table of models, models are ordered based on stat of interest (i.e. r2, aic, bic)
plot(leaps, scale = "r2")
full_reg <- lm(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
avg_log_value + log(port_value) + mega_subregion + value_cat, input)
summary(full_reg)
#full regression results table
sjt.lm(full_reg,  emph.p = TRUE, digits.est = 3)
mydata <- ggpredict(full_reg,
terms = c("avg_index
[1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2,
2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3,
3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4,
4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5,
5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 6,
6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8, 6.9, 7,
7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, 7.9, 8]", "mega_subregion"))
ggplot(mydata, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
mydata <- ggpredict(full_reg,
terms = c("avg_index
[1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2,
2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3,
3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4,
4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5,
5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 6,
6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8, 6.9, 7,
7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, 7.9, 8]", "mega_subregion"))
mydata_value <- ggpredict(full_reg,
terms = c("avg_index
[1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2,
2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3,
3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4,
4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5,
5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 6,
6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8, 6.9, 7,
7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, 7.9, 8]", "value_cat"))
ggplot(mydata_value, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
input %>% group_by(value_cat) %>% summarise(
mean_cv = mean(cv_revenue))
full_reg <- lm(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
log(port_value) + mega_subregion + value_cat, input)
x_mod <- paste(x, collapse = ", ")
mydata <- ggpredict(full_reg,
terms = c("avg_index
[1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2,
2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3,
3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4,
4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5,
5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 6,
6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8, 6.9, 7,
7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, 7.9, 8]", "mega_subregion"))
mydata_value <- ggpredict(full_reg,
terms = c("avg_index
[1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2,
2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3,
3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4,
4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5,
5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 6,
6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8, 6.9, 7,
7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, 7.9, 8]", "value_cat"))
ggplot(mydata_value, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
ggplot(mydata, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
ggplot(mydata_value, aes(x, predicted)) + geom_line() +
facet_wrap(~group)
leaps <- regsubsets(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
value_cat + log(port_value) + mega_subregion + value_cat, data = input, nbest = 5)
#results from all-subsets regression (LOOK AT PLOT)
summary(leaps)
##plot a table of models, models are ordered based on stat of interest (i.e. r2, aic, bic)
plot(leaps, scale = "r2")
##plot a table of models, models are ordered based on stat of interest (i.e. r2, aic, bic)
plot(leaps, scale = "r2")
library(leaps)
#all-subsets regression package
library(MASS)
leaps <- regsubsets(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
value_cat + log(port_value) + mega_subregion + value_cat, data = input, nbest = 5)
#results from all-subsets regression (LOOK AT PLOT)
summary(leaps)
##plot a table of models, models are ordered based on stat of interest (i.e. r2, aic, bic)
plot(leaps, scale = "r2")
summary(full_reg)
full_reg_novalue <- lm(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
log(port_value) + log(avg_value) + mega_subregion + , input)
full_reg_novalue <- lm(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
log(port_value) + log(avg_value) + mega_subregion , input)
summary(full_reg_novalue)
##plot a table of models, models are ordered based on stat of interest (i.e. r2, aic, bic)
plot(leaps, scale = "r2")
leaps?
leaps?
?leaps
?leaps
leaps_novalue <- regsubsets(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
value_cat + log(port_value) + log(avg_value) + mega_subregion, data = input, nbest = 5)
plot(leaps, scale = "r2")
plot(leaps_novalue, scale = "r2")
leaps <- regsubsets(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
value_cat + log(port_value) + mega_subregion, data = input, nbest = 5)
leaps_novalue <- regsubsets(cv_revenue ~ avg_index + I(avg_index^2) + port_index + I(port_index^2) +
log(port_value) + log(avg_value) + mega_subregion, data = input, nbest = 5)
#results from all-subsets regression (LOOK AT PLOT)
summary(leaps)
##plot a table of models, models are ordered based on stat of interest (i.e. r2, aic, bic)
plot(leaps, scale = "r2")
plot(leaps_novalue, scale = "r2")
summary(full_reg_novalue)
summary(full_reg)
?leaps
glimpse(input)
#assessing vol - catch div relationship for boats and ports using GAM via ggplot2
ggplot(input, aes(avg_index, cv_revenue)) + geom_point() + geom_smooth(method = "GAM")
#assessing vol - catch div relationship for boats and ports using GAM via ggplot2
ggplot(input, aes(avg_index, cv_revenue)) + geom_point() + geom_smooth(method = "gam")
#assessing vol - catch div relationship for boats and ports using GAM via ggplot2
ggplot(input, aes(avg_index, cv_revenue)) + geom_point() + geom_smooth()
?geom_smooth
glimpse
glimpse(input)
ggplot(input, aes(port_index, port_cv_revenue)) + geom_point() +
geom_smooth() +
ggtitle("PORT level relationship between vol and div")
boat_linear <- lm(cv_revenue ~ avg_index, input)
boat_quadratic <- lm(cv_reveneu ~ avg_index + + I(avg_index^2), input)
boat_linear <- lm(cv_revenue ~ avg_index, input)
boat_quadratic <- lm(cv_revenue ~ avg_index + + I(avg_index^2), input)
summary(boat_linear)
summary(boat_quadratic)
